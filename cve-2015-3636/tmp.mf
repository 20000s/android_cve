net/socket.c

```c
SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,
        int, addrlen)
{
    struct socket *sock;
    int err, fput_needed;

    sock = sockfd_lookup_light(fd, &err, &fput_needed);
    ...
    err = sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,
                 sock->file->f_flags);
    ...
}
```

当我们调用connect函数时,它会调用sock->op->connect函数，接下来我们看看sock的结构体

include/linux/net.h

```c
struct socket {
    ...
    struct sock     *sk; // internal networking protocol agnostic socket representation
    const struct proto_ops  *ops; // ops: protocol specific socket operations
};
const struct proto_ops inet_dgram_ops = {
    .family        = PF_INET,
    .owner         = THIS_MODULE,
    .release       = inet_release,
    .bind          = inet_bind,
    .connect       = inet_dgram_connect, // 这里的初始化使connect进入inet_dgram_connect函数
```

可以看到socket里面的函数表中ops里的connect被初始化为inet_dgram_connect,然为我们跟踪inet_dgram_connect

```c
int inet_dgram_connect(struct socket *sock, struct sockaddr *uaddr,
               int addr_len, int flags)
{
    struct sock *sk = sock->sk;

    if (addr_len < sizeof(uaddr->sa_family))
        return -EINVAL;
    if (uaddr->sa_family == AF_UNSPEC)
        return sk->sk_prot->disconnect(sk, flags);

    if (!inet_sk(sk)->inet_num && inet_autobind(sk))
        return -EAGAIN;
    return sk->sk_prot->connect(sk, uaddr, addr_len);
}
```

根据概述所说 sa_family == AF_UNSPEC，所以会执行sk->sk_prot->disconnect(sk, flags)，而sk->sk_prot->disconnect(sk, flags)最终会调用udp_disconnect(struct sock *sk, int flag)

net/ipv4/udp.c

```c
int udp_disconnect(struct sock *sk, int flags)
{
    struct inet_sock *inet = inet_sk(sk);

    sk->sk_state = TCP_CLOSE;
    ...
    if (!(sk->sk_userlocks & SOCK_BINDPORT_LOCK)) {
        sk->sk_prot->unhash(sk);
        inet->inet_sport = 0;
    }
    sk_dst_reset(sk);
    return 0;
}
```

在socket对象不绑定端口的情况下，会执行sk->sk_prot_unhash(sk);而sk->sk_prot_unhash(sk)最终会执行ping_unhash(struct sock *sk)

net/ipv4/ping.c

```c
void ping_unhash(struct sock *sk)
{
    struct inet_sock *isk = inet_sk(sk);
    pr_debug("ping_unhash(isk=%p,isk->num=%u)\n", isk, isk->inet_num);
    if (sk_hashed(sk)) {
        write_lock_bh(&ping_table.lock);
        hlist_nulls_del(&sk->sk_nulls_node);
      //  sk_nulls_node_init(&sk->sk_nulls_node);
        sock_put(sk);
        isk->inet_num = 0;
        isk->inet_sport = 0;
        sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
        write_unlock_bh(&ping_table.lock);
    }
}
```

在ping_unhash()，如果sk_hashed的条件满足，就会执行hlist_nulls_del

```c
define sk_node            __sk_common.skc_node
#define sk_nulls_node      __sk_common.skc_nulls_node
 
    union {
        struct hlist_node  skc_node;
        struct hlist_nulls_node skc_nulls_node;
    };
 
struct hlist_node {
    struct hlist_node *next, **pprev;
};
 
struct hlist_nulls_node {
    struct hlist_nulls_node *next, **pprev;
};

static inline void __hlist_nulls_del(struct hlist_nulls_node *n)
{
         struct hlist_nulls_node *next = n->next;
         struct hlist_nulls_node **pprev = n->pprev;
         *pprev = next;
         if (!is_a_nulls(next))
                   next->pprev = pprev;
}
 
static inline void hlist_nulls_del(struct hlist_nulls_node *n)
{
         __hlist_nulls_del(n);
         n->pprev = LIST_POISON2;
}
```

当执行hlist_nulls_node后n的pprev被设置为LIST_POISON2，其值固定为0x200200,如果sk_hashed的条件成立，再次对同一个sock的sk_nulls_node删除时，也就是删除已经删除的对象，执行*pprev = next时pprev已经是0x200200了，如果这个地址没有映射到用户态就会kernel panic，来看一下第二次调用connect时，sk_hashed的条件是否成立

```c
static inline int sk_unhashed(const struct sock *sk)
{
         return hlist_unhashed(&sk->sk_node);
}
 
static inline int sk_hashed(const struct sock *sk)
{
         return !sk_unhashed(sk);
}
 
static inline int hlist_unhashed(const struct hlist_node *h)
{
         return !h->pprev;
}
```

只是用来判断是不是等于null,显然可以顺利通过检测

还有个小问题就是在两次connect前，还要再使用sin_family==AF_INET connect一下,让sk加入hlist
